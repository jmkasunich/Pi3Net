.pio_version 0

.define PUBLIC p3n_clocks_per_bit	8
.define PUBLIC p3n_bits_per_word	8

; shorter local names for the above
.define cpb 	(p3n_clocks_per_bit)
.define bpw 	(p3n_bits_per_word)

.program p3n_rxtx

; program configuration
; the PIO program has one pin for both receive and transmit
; the pindir is set to output during transmit only

.fifo txrx
.mov_status txfifo < 1
.in 32 right bpw
.out 1 right bpw
.set 1
.side_set 1

PUBLIC txbegin:
	pull block      		side 0              ; grab data (stall if none)
    set pindirs 1           side 0              ; make pin an output
	set pins 0              side 0  [(cpb-1)]   ; start bit 1
tx_word_loop:
	set pins 1              side 0  [(cpb-2)]   ; start bit 2
    pull ifempty            side 0              ; this will never block
tx_bit_loop:
	out pins, 1             side 0  [(cpb-3)]   ; send a bit
	mov x, status           side 0              ; check tx fifo, 0 = more data
	jmp !OSRE, tx_bit_loop  side 0              ; loop till all bits sent
    mov pins, x             side 0  [(cpb-2)]   ; send start bit 1 or stop bit
	jmp !x, tx_word_loop    side 0              ; jump if more data to send
    set pindirs 0           side 1              ; tri-state the output pin
msg_done:
    irq nowait 0 rel        side 1              ; tell the MCU that we are done
    jmp start_wait          side 0              ; start measuring idle time
wait_loop:
	jmp pin, still_hi		side 1              ; jump if still high
PUBLIC start_wait:                              ; reset timeouts
	set x, (cpb-1)	    	side 0              ; inner loop = 2 bit times
	set y, (bpw/2)  		side 0              ; outer loop, word size + 2 bits
still_hi:
	jmp x--, wait_loop		side 0              ; inner loop
	set x, (cpb-1)  	    side 0              ; reset inner loop
	jmp y--, wait_loop		side 0              ; outer loop
PUBLIC idle_wait:
	wait 0 pin 0			side 1              ; find falling edge of 1st start pulse
.wrap_target
	wait 1 pin 0			side 0              ; find rising edge of 2nd start pulse
	set X, (bpw-1)          side 0  [cpb+1]     ; set bit count, delay to mid data bit
sample_loop:
	in pins, 1              side 1              ; get bit into ISR
	jmp x--, sample_loop    side 0  [cpb-2]     ; loop for each bit
	push noblock            side 0              ; save data
	jmp pin, msg_done   	side 1              ; check start/stop bit, jump if no more data
.wrap                                           ; loop around for next word 


% c-sdk {

// hello, a comment passed thru the assembler

%}