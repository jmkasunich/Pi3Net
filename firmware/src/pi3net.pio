.pio_version 0

; clocks per bit, for delays
.define PUBLIC cpb 8

; bits per word
.define PUBLIC bpw 8

.program p3n_tx

; send a message

.fifo tx
.mov_status txfifo < 1
.out 1 right bpw
.set 1
.side_set 1

.wrap_target
PUBLIC txbegin:
	pull block      		side 0              ; grab data (stall if none)
	set pins 0              side 0  [(cpb-1)]   ; start bit 1
wordloop:
	set pins 1              side 0  [(cpb-2)]   ; start bit 2
    pull ifempty            side 0              ; this will never block
bitloop:
	out pins, 1             side 0  [(cpb-3)]   ; send a bit
	mov x, status           side 0              ; check tx fifo, 0 = more data
	jmp !OSRE, bitloop      side 0              ; loop till all bits sent
    mov pins, x             side 0  [(cpb-2)]   ; send start bit 1 or stop bit
	jmp !x, wordloop        side 0              ; jump if more data to send

    irq wait 0 rel          side 1              ; tell the MCU that we are done
.wrap


.program p3n_rx

; receive a message

.fifo rx
.in 32 right bpw
.set 0
.side_set 1


wait4idle1:
	jmp pin, wait4idle2		side 1              ; jump if still high
.wrap_target
PUBLIC rxbegin:                                 ; reset timeouts
	set x, (cpb-1)	    	side 0              ; inner loop = 2 bit times
	set y, (bpw/2)  		side 0              ; outer loop, word size + 2 bits
wait4idle2:
	jmp x--, wait4idle1		side 0              ; inner loop
	set x, (cpb-1)  	    side 0              ; reset inner loop
	jmp y--, wait4idle1		side 0              ; outer loop
wait4start:
	wait 0 pin 0			side 0              ; find falling edge of 1st start pulse
wait4rise:
	wait 1 pin 0			side 0              ; find rising edge of 2nd start pulse
	set X, (bpw-1)          side 0  [cpb+1]     ; set bit count, delay to mid data bit
sample:
	in pins, 1              side 1              ; get bit into ISR
	jmp x--, sample         side 0  [cpb-2]     ; loop for each bit
	push noblock            side 0              ; save data
	jmp pin, message_end	side 1              ; check start/stop bit, jump if no more data
    jmp wait4rise           side 0              ; loop around for next word 

message_end:
    nop                     side 0              ; mark end of message
    nop                     side 1  [cpb]       ; mark end of message
.wrap                                           ; start looking for next msg


% c-sdk {

// hello, a comment passed thru the assembler

%}